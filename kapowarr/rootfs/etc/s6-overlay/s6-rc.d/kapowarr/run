#!/usr/bin/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# s6-rc.d/kapowarr/run â€” Kapowarr service run script
#
# s6-overlay v3 calls this script to START the Kapowarr application service.
# The script MUST run the application in the FOREGROUND.
# ==============================================================================

# Redirect stderr to stdout
exec 2>&1

bashio::log.info "Starting Kapowarr..."

# ---------------------------------------------------------------------------
# Read configuration from s6 container environment (exported by kapowarr-setup)
# ---------------------------------------------------------------------------
declare log_level="${LOG_LEVEL:-info}"
bashio::log.level "${log_level}"
bashio::log.info "Log level: ${log_level}"

# ---------------------------------------------------------------------------
# Set runtime environment variables
# ---------------------------------------------------------------------------
export TZ="${TZ:-UTC}"

# Get the port from environment or default to 5656
declare app_port
app_port="${APP_PORT:-5656}"

bashio::log.info "Kapowarr will listen on 0.0.0.0:${app_port}"

# ---------------------------------------------------------------------------
# Resolve HA ingress path for Kapowarr's native url_base setting
# ---------------------------------------------------------------------------
# Kapowarr supports a url_base setting that wraps the Flask app with
# DispatcherMiddleware, making all routes, static assets, API endpoints,
# and WebSocket paths respect the prefix natively. This eliminates the
# need for nginx sub_filter rewriting.
#
# The ingress path (e.g. /api/hassio_ingress/<token>) is stable across
# container restarts and only changes on add-on reinstall.
declare ingress_path
ingress_path="$(bashio::addon.ingress_entry)"
bashio::log.info "Ingress path (url_base): ${ingress_path}"

# ---------------------------------------------------------------------------
# Change to the application directory
# ---------------------------------------------------------------------------
cd /app || bashio::exit.nok "Could not change to /app directory"

# ---------------------------------------------------------------------------
# Configure settings in database
# Kapowarr stores settings in the config table as key/value pairs.
# ---------------------------------------------------------------------------

# Map log level string to Python logging integer
declare log_level_int
case "${log_level}" in
    trace)  log_level_int=5 ;;
    debug)  log_level_int=10 ;;
    info)   log_level_int=20 ;;
    warning) log_level_int=30 ;;
    error)  log_level_int=40 ;;
    *)      log_level_int=20 ;;
esac

declare db_file="/config/data/Kapowarr.db"

# Update settings if database already exists (subsequent starts)
if [[ -f "${db_file}" ]]; then
    sqlite3 "${db_file}" \
        "UPDATE config SET value = ${log_level_int} WHERE key = 'log_level';" \
        2>/dev/null || true
    sqlite3 "${db_file}" \
        "UPDATE config SET value = '${ingress_path}' WHERE key = 'url_base';" \
        2>/dev/null || true
    bashio::log.debug "Pre-start DB update: log_level=${log_level} (${log_level_int}), url_base=${ingress_path}"
fi

# ---------------------------------------------------------------------------
# Start Kapowarr with database folder for persistent storage
# Start in background so we can update settings after DB initialization
# ---------------------------------------------------------------------------
python3 /app/Kapowarr.py -d /config/data &
kapowarr_pid=$!

# Wait for Kapowarr to initialize the database (first run creates it)
sleep 3

if [[ -f "${db_file}" ]]; then
    sqlite3 "${db_file}" \
        "UPDATE config SET value = ${log_level_int} WHERE key = 'log_level';" \
        2>/dev/null || true
    sqlite3 "${db_file}" \
        "UPDATE config SET value = '${ingress_path}' WHERE key = 'url_base';" \
        2>/dev/null || true
    bashio::log.debug "Post-init DB update: log_level=${log_level} (${log_level_int}), url_base=${ingress_path}"
fi

# Re-foreground the process by waiting for it
# This replaces the current shell with Kapowarr for proper signal handling
exec wait $kapowarr_pid
