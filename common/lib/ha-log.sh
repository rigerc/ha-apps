#!/usr/bin/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# ha-log.sh — Shared logging library for Home Assistant add-ons
#
# USAGE
#   Source this file at the top of any init or service script:
#
#     # shellcheck source=/usr/local/lib/ha-framework/ha-log.sh
#     source /usr/local/lib/ha-framework/ha-log.sh
#
#   Then call the logging functions:
#
#     ha::log::info  "APP_NAME" "Server started on port 8080"
#     ha::log::debug "APP_NAME" "Request received: GET /"
#     ha::log::warn  "APP_NAME" "Config file not found, using defaults"
#     ha::log::error "APP_NAME" "Failed to connect to database"
#
#   Or use the component-prefixed helpers generated by ha::log::init:
#
#     ha::log::init "APP_NAME"          # call once at script top
#     log_info  "Server started"         # equivalent to ha::log::info "APP_NAME" ...
#     log_debug "Request received"
#     log_warn  "Using defaults"
#     log_error "Connection failed"
#
# LOG LEVELS (controlled by 'log_level' add-on option)
#   trace   — extremely verbose; every function call and variable value
#   debug   — diagnostic messages useful during development
#   info    — normal operational messages (default)
#   warning — non-fatal issues that may need attention
#   error   — fatal errors; service will likely stop
#
# OUTPUT
#   All log output goes to stdout/stderr (captured by s6-overlay and displayed
#   in Home Assistant add-on log panel).
#   File logging is optional — set HA_LOG_FILE to enable (see below).
#
# ENVIRONMENT VARIABLES
#   HA_LOG_LEVEL    — override of bashio log level (trace|debug|info|warning|error)
#                     defaults to 'log_level' option from /data/options.json
#   HA_LOG_FILE     — if set to a path, log messages are ALSO written to that file
#                     example: export HA_LOG_FILE=/data/APP_NAME.log
#   HA_LOG_MAX_SIZE — maximum log file size in bytes before rotation (default: 1048576 = 1 MiB)
#   HA_LOG_BACKUPS  — number of rotated log files to keep (default: 3)
# ==============================================================================

# Guard against double-sourcing
[[ -n "${_HA_LOG_LOADED:-}" ]] && return 0
readonly _HA_LOG_LOADED=1

# ---------------------------------------------------------------------------
# Internal: determine the effective log level as a numeric value
#   0 = trace, 1 = debug, 2 = info, 3 = warning, 4 = error
# ---------------------------------------------------------------------------
_ha_log_level_num() {
    local level="${1:-info}"
    case "${level,,}" in
        trace)   echo 0 ;;
        debug)   echo 1 ;;
        info)    echo 2 ;;
        warning|warn) echo 3 ;;
        error)   echo 4 ;;
        *)       echo 2 ;;  # default to info for unknown levels
    esac
}

# Resolve effective log level once and cache it.
# Priority: HA_LOG_LEVEL env var > bashio config 'log_level' > "info"
#
# IMPORTANT: Also syncs of level to bashio's internal __BASHIO_LOG_LEVEL
# so that bashio::log.debug/trace actually output when requested.
# Without this, bashio silently filters debug/trace even when add-on
# option is set to debug (bashio defaults to INFO level 5, DEBUG is 6).
_ha_log_resolve_level() {
    local level="info"

    if [[ -n "${HA_LOG_LEVEL:-}" ]]; then
        level="${HA_LOG_LEVEL}"
    elif configured_level="$(bashio::config 'log_level' 2>/dev/null)" && [[ -n "${configured_level}" ]]; then
        level="${configured_level}"
    fi

    # Sync to bashio's log level so bashio::log.debug/trace work
    # This sets __BASHIO_LOG_LEVEL appropriately (debug=6, info=5, etc.)
    bashio::log.level "${level}" 2>/dev/null || true

    echo "${level}"
}

# Cache resolved level in a global variable on first use
_HA_LOG_EFFECTIVE_LEVEL=""
_ha_log_get_effective_level() {
    if [[ -z "${_HA_LOG_EFFECTIVE_LEVEL}" ]]; then
        _HA_LOG_EFFECTIVE_LEVEL="$(_ha_log_resolve_level)"
    fi
    echo "${_HA_LOG_EFFECTIVE_LEVEL}"
}

# Force a re-read of log level (call if options may have changed)
ha::log::reload_level() {
    _HA_LOG_EFFECTIVE_LEVEL=""
}

# ---------------------------------------------------------------------------
# Internal: write a single log line
#   $1 — severity string  (TRACE|DEBUG|INFO|WARN|ERROR)
#   $2 — component/prefix (e.g., "APP_NAME" or "nginx")
#   $3 — message
# ---------------------------------------------------------------------------
_ha_log_write() {
    local severity="${1}"
    local component="${2}"
    local message="${3}"
    local timestamp

    timestamp="$(date '+%Y-%m-%dT%H:%M:%S%z')"
    local line="[${timestamp}] [${severity}] [${component}] ${message}"

    # Route all messages through bashio::log.info.
    # ha-log.sh already filters by effective level before calling this function,
    # so severity-specific bashio functions (log.debug, log.warning, etc.) are
    # not needed for filtering. Calling them can trigger a bashio nameref bug
    # ("debug: unbound variable") when log level names are used as variable
    # references internally by bashio under set -u.
    bashio::log.info "${line}"

    # Optional file logging
    if [[ -n "${HA_LOG_FILE:-}" ]]; then
        _ha_log_write_file "${line}"
    fi
}

# ---------------------------------------------------------------------------
# Internal: append a line to log file, rotating if necessary
# ---------------------------------------------------------------------------
_ha_log_write_file() {
    local line="${1}"
    local log_file="${HA_LOG_FILE}"
    local max_size="${HA_LOG_MAX_SIZE:-1048576}"  # 1 MiB default
    local backups="${HA_LOG_BACKUPS:-3}"

    # Ensure parent directory exists
    local log_dir
    log_dir="$(dirname "${log_file}")"
    [[ -d "${log_dir}" ]] || mkdir -p "${log_dir}"

    # Rotate if file exceeds maximum size
    if [[ -f "${log_file}" ]]; then
        local current_size
        current_size="$(wc -c < "${log_file}" 2>/dev/null || echo 0)"
        if (( current_size >= max_size )); then
            _ha_log_rotate "${log_file}" "${backups}"
        fi
    fi

    echo "${line}" >> "${log_file}"
}

# ---------------------------------------------------------------------------
# Internal: rotate log files (log → log.1 → log.2 → ... → log.N → deleted)
# ---------------------------------------------------------------------------
_ha_log_rotate() {
    local log_file="${1}"
    local backups="${2}"

    # Remove the oldest backup
    [[ -f "${log_file}.${backups}" ]] && rm -f "${log_file}.${backups}"

    # Shift existing backups
    local i
    for (( i = backups - 1; i >= 1; i-- )); do
        [[ -f "${log_file}.${i}" ]] && mv "${log_file}.${i}" "${log_file}.$((i + 1))"
    done

    # Rotate current log to .1
    [[ -f "${log_file}" ]] && mv "${log_file}" "${log_file}.1"
}

# ---------------------------------------------------------------------------
# Public API: ha::log::<level> <component> <message>
# ---------------------------------------------------------------------------

ha::log::trace() {
    local component="${1:-APP}"
    local message="${2:-}"
    local effective_num
    effective_num="$(_ha_log_level_num "$(_ha_log_get_effective_level)")"
    (( effective_num <= 0 )) && _ha_log_write "TRACE" "${component}" "${message}"
    return 0
}

ha::log::debug() {
    local component="${1:-APP}"
    local message="${2:-}"
    local effective_num
    effective_num="$(_ha_log_level_num "$(_ha_log_get_effective_level)")"
    (( effective_num <= 1 )) && _ha_log_write "DEBUG" "${component}" "${message}"
    return 0
}

ha::log::info() {
    local component="${1:-APP}"
    local message="${2:-}"
    local effective_num
    effective_num="$(_ha_log_level_num "$(_ha_log_get_effective_level)")"
    (( effective_num <= 2 )) && _ha_log_write "INFO" "${component}" "${message}"
    return 0
}

ha::log::warn() {
    local component="${1:-APP}"
    local message="${2:-}"
    local effective_num
    effective_num="$(_ha_log_level_num "$(_ha_log_get_effective_level)")"
    (( effective_num <= 3 )) && _ha_log_write "WARN" "${component}" "${message}"
    return 0
}

# Alias for consistency with HA naming conventions
ha::log::warning() { ha::log::warn "$@"; }

ha::log::error() {
    local component="${1:-APP}"
    local message="${2:-}"
    # Errors are always emitted regardless of log level
    _ha_log_write "ERROR" "${component}" "${message}"
    return 0
}

# ---------------------------------------------------------------------------
# ha::log::init <component>
#
# Generates short-form aliases (log_info, log_debug, log_warn, log_error,
# log_trace) scoped to the given component name.
#
# Call once near the top of a script:
#   ha::log::init "nginx"
#   log_info "Starting nginx..."
# ---------------------------------------------------------------------------
ha::log::init() {
    local component="${1:-APP}"

    # Use eval to create component-scoped wrapper functions in the calling scope.
    # shellcheck disable=SC2016
    eval "
log_trace()  { ha::log::trace  '${component}' \"\$*\"; }
log_debug()  { ha::log::debug  '${component}' \"\$*\"; }
log_info()   { ha::log::info   '${component}' \"\$*\"; }
log_warn()   { ha::log::warn   '${component}' \"\$*\"; }
log_warning(){ ha::log::warn   '${component}' \"\$*\"; }
log_error()  { ha::log::error  '${component}' \"\$*\"; }
"
}

# ---------------------------------------------------------------------------
# ha::log::banner <title> [version]
#
# Prints a startup banner to the log. Useful in cont-init.d/00-banner.sh.
# Example:
#   ha::log::banner "APP_NAME" "1.2.3"
# ---------------------------------------------------------------------------
ha::log::banner() {
    local title="${1:-APP_NAME}"
    local version="${2:-}"
    local version_str=""
    [[ -n "${version}" ]] && version_str=" v${version}"

    bashio::log.info "---"
    bashio::log.info "${title}${version_str}"
    bashio::log.info "Initializing add-on..."
    bashio::log.info "---"
}

# ---------------------------------------------------------------------------
# ha::log::section <heading>
#
# Prints a visible section separator in the log. Useful for grouping
# related log messages during long initialization sequences.
# Example:
#   ha::log::section "Database migration"
# ---------------------------------------------------------------------------
ha::log::section() {
    local heading="${1:-}"
    bashio::log.info "--- ${heading} ---"
}
